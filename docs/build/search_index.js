var documenterSearchIndex = {"docs":
[{"location":"references.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"references.html#Key-Papers-and-Books","page":"References","title":"Key Papers and Books","text":"Pearl, J. (2009). Causality: Models, Reasoning, and Inference (2nd ed.). Cambridge University Press.\nShpitser, I., & Pearl, J. (2006). Identification of joint interventional distributions in recursive semi-Markovian causal models. Proceedings of the 21st National Conference on Artificial Intelligence.\nHofmann, T., et al. (2023). Spectral Dynamic Causal Modelling with ModelingToolkit.jl. [Reference details]","category":"section"},{"location":"references.html#Related-Packages","page":"References","title":"Related Packages","text":"Graphs.jl: Graph data structures and algorithms\nModelingToolkit.jl: Symbolic modeling framework\nSymbolics.jl: Symbolic computation\nForwardDiff.jl: Automatic differentiation","category":"section"},{"location":"references.html#Further-Reading","page":"References","title":"Further Reading","text":"For deeper conceptual background and worked examples, see the CDCS Book.","category":"section"},{"location":"getting-started.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started.html#Installation","page":"Getting Started","title":"Installation","text":"Install CausalDynamics.jl using Julia's package manager:\n\nusing Pkg\nPkg.add(\"CausalDynamics\")\n\nFor the latest development version:\n\nusing Pkg\nPkg.add(url=\"https://github.com/yourusername/CausalDynamics.jl.git\")","category":"section"},{"location":"getting-started.html#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"","category":"section"},{"location":"getting-started.html#Creating-a-Causal-Graph","page":"Getting Started","title":"Creating a Causal Graph","text":"using CausalDynamics\nusing Graphs\n\n# Create a simple causal graph\ng = DiGraph(3)\nadd_edge!(g, 1, 2)  # Z → X\nadd_edge!(g, 1, 3)  # Z → Y\nadd_edge!(g, 2, 3)  # X → Y","category":"section"},{"location":"getting-started.html#Checking-d-Separation","page":"Getting Started","title":"Checking d-Separation","text":"# Check if X and Y are d-separated by Z\nd_separated(g, 2, 3, [1])  # true (Z blocks the path)","category":"section"},{"location":"getting-started.html#Finding-Adjustment-Sets","page":"Getting Started","title":"Finding Adjustment Sets","text":"# Find a backdoor adjustment set\nadj_set = backdoor_adjustment_set(g, 2, 3)  # Set([1])","category":"section"},{"location":"getting-started.html#Next-Steps","page":"Getting Started","title":"Next Steps","text":"See the API Reference for detailed function documentation\nCheck the Examples for more comprehensive usage\nRead the CDCS Book for conceptual background","category":"section"},{"location":"api/scm.html#SCM-Framework","page":"SCM Framework","title":"SCM Framework","text":"","category":"section"},{"location":"api/scm.html#CausalDynamics.AbstractSCM","page":"SCM Framework","title":"CausalDynamics.AbstractSCM","text":"AbstractSCM\n\nAbstract type for Structural Causal Models.\n\n\n\n\n\n","category":"type"},{"location":"api/scm.html#CausalDynamics.GraphSCM","page":"SCM Framework","title":"CausalDynamics.GraphSCM","text":"GraphSCM\n\nA Structural Causal Model represented as a graph and structural equations.\n\nFields\n\ngraph: Directed acyclic graph\nequations: Dictionary mapping nodes to functions\nexogenous: Set of exogenous nodes\n\n\n\n\n\n","category":"type"},{"location":"api/scm.html#CausalDynamics.SymbolicSCM","page":"SCM Framework","title":"CausalDynamics.SymbolicSCM","text":"SymbolicSCM\n\nA Structural Causal Model with symbolic equations (using ModelingToolkit.jl).\n\nFields\n\ngraph: Directed acyclic graph\nsystem: ModelingToolkit system\nexogenous: Set of exogenous variable names\n\n\n\n\n\n","category":"type"},{"location":"api/scm.html#CausalDynamics.create_symbolic_scm","page":"SCM Framework","title":"CausalDynamics.create_symbolic_scm","text":"create_symbolic_scm(graph, equations_dict)\n\nCreate a symbolic SCM from a graph and dictionary of equations.\n\nArguments\n\ngraph: Directed acyclic graph\nequations_dict: Dictionary mapping node names to symbolic equations\n\nReturns\n\nSymbolicSCM object\n\nExamples\n\nusing CausalDynamics, Graphs, ModelingToolkit, Symbolics\n\n@variables x, y, z, u_x, u_y\n@parameters α, β\n\ng = DiGraph(3)\nadd_edge!(g, 1, 2)  # X → Y\nadd_edge!(g, 3, 1)  # Z → X\n\nequations = Dict(\n    :x => α * z + u_x,\n    :y => β * x + u_y,\n    :z => u_x  # Exogenous\n)\n\nscm = create_symbolic_scm(g, equations)\n\n\n\n\n\n","category":"function"},{"location":"api/scm.html#CausalDynamics.DoIntervention","page":"SCM Framework","title":"CausalDynamics.DoIntervention","text":"DoIntervention\n\nRepresents a do(·) intervention.\n\nFields\n\nvariable: Variable to intervene on\nvalue: Value to set\n\n\n\n\n\n","category":"type"},{"location":"api/scm.html#CausalDynamics.apply_intervention","page":"SCM Framework","title":"CausalDynamics.apply_intervention","text":"apply_intervention(scm, intervention)\n\nApply a do(·) intervention to an SCM.\n\nArguments\n\nscm: Structural Causal Model\nintervention: DoIntervention object\n\nReturns\n\nModified SCM with intervention applied\n\nExamples\n\nusing CausalDynamics\n\nintervention = DoIntervention(:x, 1.0)\nscm_intervened = apply_intervention(scm, intervention)\n\n\n\n\n\n","category":"function"},{"location":"api/scm.html#CausalDynamics.do_intervention","page":"SCM Framework","title":"CausalDynamics.do_intervention","text":"do_intervention(variable, value)\n\nConvenience function to create a DoIntervention.\n\nExamples\n\nintervention = do_intervention(:x, 1.0)\n\n\n\n\n\n","category":"function"},{"location":"api/scm.html#CausalDynamics.counterfactual_graph","page":"SCM Framework","title":"CausalDynamics.counterfactual_graph","text":"counterfactual_graph(scm, intervention)\n\nGenerate a counterfactual graph for a given intervention.\n\nArguments\n\nscm: Structural Causal Model\nintervention: Intervention to apply\n\nReturns\n\nCounterfactual SCM\n\nNote\n\nCounterfactuals require shared exogenous noise. This function generates the graph structure for counterfactual reasoning.\n\n\n\n\n\n","category":"function"},{"location":"api/identification.html#Identification-Algorithms","page":"Identification","title":"Identification Algorithms","text":"","category":"section"},{"location":"api/identification.html#CausalDynamics.backdoor_adjustment_set","page":"Identification","title":"CausalDynamics.backdoor_adjustment_set","text":"backdoor_adjustment_set(g, X, Y)\n\nFind a valid backdoor adjustment set for estimating the causal effect of X on Y.\n\nThe backdoor criterion states that a set Z is a valid adjustment set if:\n\nZ blocks all backdoor paths from X to Y\nZ does not contain any descendants of X\n\nArguments\n\ng: Directed acyclic graph\nX: Treatment node\nY: Outcome node\n\nReturns\n\nSet of nodes that form a valid backdoor adjustment set, or nothing if no valid set exists\n\nExamples\n\nusing CausalDynamics, Graphs\n\n# Confounding example\ng = DiGraph(3)\nadd_edge!(g, 1, 2)  # Z → X\nadd_edge!(g, 1, 3)  # Z → Y\nadd_edge!(g, 2, 3)  # X → Y\n\n# Z is a valid adjustment set\nadj_set = backdoor_adjustment_set(g, 2, 3)  # Set([1])\n\nReferences\n\nPearl, J. (2009). Causality, Chapter 3\n\n\n\n\n\n","category":"function"},{"location":"api/identification.html#CausalDynamics.is_backdoor_adjustable","page":"Identification","title":"CausalDynamics.is_backdoor_adjustable","text":"is_backdoor_adjustable(g, X, Y)\n\nCheck if the causal effect of X on Y is identifiable via backdoor adjustment.\n\nArguments\n\ng: Directed acyclic graph\nX: Treatment node\nY: Outcome node\n\nReturns\n\ntrue if backdoor adjustment is possible, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"api/identification.html#CausalDynamics.frontdoor_adjustment_set","page":"Identification","title":"CausalDynamics.frontdoor_adjustment_set","text":"frontdoor_adjustment_set(g, X, Y, M)\n\nCheck if M is a valid frontdoor adjustment set for estimating the causal effect of X on Y.\n\nThe frontdoor criterion states that a set M is a valid frontdoor adjustment set if:\n\nM blocks all directed paths from X to Y\nThere are no backdoor paths from X to M\nAll backdoor paths from M to Y are blocked by X\n\nArguments\n\ng: Directed acyclic graph\nX: Treatment node\nY: Outcome node\nM: Potential mediator set\n\nReturns\n\ntrue if M is a valid frontdoor adjustment set, false otherwise\n\nExamples\n\nusing CausalDynamics, Graphs\n\n# Frontdoor example: X → M → Y, with confounding U\ng = DiGraph(4)\nadd_edge!(g, 1, 2)  # U → X\nadd_edge!(g, 1, 4)  # U → Y\nadd_edge!(g, 2, 3)  # X → M\nadd_edge!(g, 3, 4)  # M → Y\n\n# M is a valid frontdoor adjustment set\nis_valid = frontdoor_adjustment_set(g, 2, 4, [3])  # true\n\nReferences\n\nPearl, J. (2009). Causality, Chapter 3\n\n\n\n\n\n","category":"function"},{"location":"api/identification.html#CausalDynamics.find_frontdoor_mediators","page":"Identification","title":"CausalDynamics.find_frontdoor_mediators","text":"find_frontdoor_mediators(g, X, Y)\n\nFind potential frontdoor mediators between X and Y.\n\nArguments\n\ng: Directed acyclic graph\nX: Treatment node\nY: Outcome node\n\nReturns\n\nVector of potential mediator sets\n\n\n\n\n\n","category":"function"},{"location":"api/identification.html#CausalDynamics.find_instruments","page":"Identification","title":"CausalDynamics.find_instruments","text":"find_instruments(g, X, Y)\n\nFind instrumental variables for estimating the causal effect of X on Y.\n\nAn instrumental variable Z must satisfy:\n\nZ has a causal effect on X\nZ affects Y only through X (exclusion restriction)\nZ is independent of confounders of X and Y (independence)\n\nArguments\n\ng: Directed acyclic graph\nX: Treatment node\nY: Outcome node\n\nReturns\n\nVector of potential instrumental variables\n\nExamples\n\nusing CausalDynamics, Graphs\n\n# IV example\ng = DiGraph(4)\nadd_edge!(g, 1, 2)  # Z → X\nadd_edge!(g, 2, 3)  # X → Y\nadd_edge!(g, 4, 2)  # U → X\nadd_edge!(g, 4, 3)  # U → Y\n\n# Z is a valid instrument\ninstruments = find_instruments(g, 2, 3)  # [1]\n\nReferences\n\nAngrist, J. D., & Pischke, J. S. (2009). Mostly Harmless Econometrics\n\n\n\n\n\n","category":"function"},{"location":"api/identification.html#CausalDynamics.is_valid_instrument","page":"Identification","title":"CausalDynamics.is_valid_instrument","text":"is_valid_instrument(g, Z, X, Y)\n\nCheck if Z is a valid instrumental variable for X → Y.\n\nArguments\n\ng: Directed acyclic graph\nZ: Potential instrument\nX: Treatment\nY: Outcome\n\nReturns\n\ntrue if Z is a valid instrument, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"api/identification.html#CausalDynamics.find_all_adjustment_sets","page":"Identification","title":"CausalDynamics.find_all_adjustment_sets","text":"find_all_adjustment_sets(g, X, Y)\n\nFind all valid adjustment sets for estimating the causal effect of X on Y.\n\nArguments\n\ng: Directed acyclic graph\nX: Treatment node\nY: Outcome node\n\nReturns\n\nVector of valid adjustment sets (each is a Set of nodes)\n\nNote\n\nThis is computationally expensive for large graphs. For practical use, consider using backdoor_adjustment_set which finds a single valid set.\n\n\n\n\n\n","category":"function"},{"location":"api/identification.html#CausalDynamics.is_valid_adjustment_set","page":"Identification","title":"CausalDynamics.is_valid_adjustment_set","text":"is_valid_adjustment_set(g, X, Y, Z)\n\nCheck if Z is a valid adjustment set for X → Y.\n\nArguments\n\ng: Directed acyclic graph\nX: Treatment node\nY: Outcome node\nZ: Adjustment set\n\nReturns\n\ntrue if Z is valid, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"api/identification.html#CausalDynamics.minimal_adjustment_set","page":"Identification","title":"CausalDynamics.minimal_adjustment_set","text":"minimal_adjustment_set(g, X, Y)\n\nFind a minimal valid adjustment set (if one exists).\n\nArguments\n\ng: Directed acyclic graph\nX: Treatment node\nY: Outcome node\n\nReturns\n\nMinimal adjustment set, or nothing if none exists\n\n\n\n\n\n","category":"function"},{"location":"api/identification.html#CausalDynamics.is_identifiable","page":"Identification","title":"CausalDynamics.is_identifiable","text":"is_identifiable(g, query)\n\nCheck if a causal query is identifiable using do-calculus.\n\nThis is a placeholder for symbolic do-calculus implementation using Symbolics.jl.\n\nArguments\n\ng: Directed acyclic graph\nquery: Causal query (to be defined)\n\nReturns\n\ntrue if identifiable, false otherwise\n\nNote\n\nFull implementation will use Symbolics.jl for symbolic manipulation. This is a stub for future development.\n\n\n\n\n\n","category":"function"},{"location":"api/identification.html#CausalDynamics.identify_formula","page":"Identification","title":"CausalDynamics.identify_formula","text":"identify_formula(g, query)\n\nGenerate an identification formula for a causal query.\n\nArguments\n\ng: Directed acyclic graph\nquery: Causal query\n\nReturns\n\nSymbolic expression representing the identified formula, or nothing if not identifiable\n\nNote\n\nThis will use Symbolics.jl to generate symbolic formulas.\n\n\n\n\n\n","category":"function"},{"location":"api/utils.html#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"api/utils.html#CausalDynamics.plot_causal_graph","page":"Utilities","title":"CausalDynamics.plot_causal_graph","text":"plot_causal_graph(g; node_labels, highlight_nodes, highlight_edges, kwargs...)\n\nPlot a causal graph with optional node labels and highlighting.\n\nArguments\n\ng::AbstractGraph: The causal graph to plot\nnode_labels::Vector{String}: Optional labels for nodes (default: node indices)\nhighlight_nodes::Set{Int}: Nodes to highlight (e.g., adjustment set)\nhighlight_edges::Vector{Tuple{Int, Int}}: Edges to highlight (e.g., backdoor paths)\nkwargs...: Additional arguments passed to GraphMakie.graphplot\n\nReturns\n\nFigure object from GraphMakie\n\nExample\n\nusing CausalDynamics, Graphs, GraphMakie, CairoMakie\n\ng = DiGraph(3)\nadd_edge!(g, 1, 2)\nadd_edge!(g, 1, 3)\nadd_edge!(g, 2, 3)\n\nfig = plot_causal_graph(g; \n    node_labels = [\"Z\", \"X\", \"Y\"],\n    highlight_nodes = Set([1])  # Highlight confounder\n)\n\nNote\n\nThis function requires GraphMakie.jl and CairoMakie.jl to be loaded.\n\n\n\n\n\n","category":"function"},{"location":"api/utils.html#CausalDynamics.plot_with_adjustment_set","page":"Utilities","title":"CausalDynamics.plot_with_adjustment_set","text":"plot_with_adjustment_set(g, X, Y, Z; node_labels, kwargs...)\n\nPlot a causal graph highlighting an adjustment set.\n\nArguments\n\ng::AbstractGraph: The causal graph\nX::Int: Treatment node\nY::Int: Outcome node\nZ::Vector{Int}: Adjustment set nodes\nnode_labels::Vector{String}: Optional node labels\nkwargs...: Additional arguments for plotting\n\nReturns\n\nFigure object\n\nExample\n\ng = DiGraph(3)\nadd_edge!(g, 1, 2)  # Z → X\nadd_edge!(g, 1, 3)  # Z → Y\nadd_edge!(g, 2, 3)  # X → Y\n\nfig = plot_with_adjustment_set(g, 2, 3, [1]; \n    node_labels = [\"Z\", \"X\", \"Y\"]\n)\n\n\n\n\n\n","category":"function"},{"location":"api/utils.html#CausalDynamics.plot_backdoor_paths","page":"Utilities","title":"CausalDynamics.plot_backdoor_paths","text":"plot_backdoor_paths(g, X, Y; node_labels, kwargs...)\n\nPlot a causal graph highlighting backdoor paths from X to Y.\n\nArguments\n\ng::AbstractGraph: The causal graph\nX::Int: Treatment node\nY::Int: Outcome node\nnode_labels::Vector{String}: Optional node labels\nkwargs...: Additional arguments for plotting\n\nReturns\n\nFigure object\n\n\n\n\n\n","category":"function"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html#Basic-Graph-Operations","page":"Examples","title":"Basic Graph Operations","text":"","category":"section"},{"location":"examples.html#d-Separation","page":"Examples","title":"d-Separation","text":"using CausalDynamics, Graphs\n\n# Create a graph: Z → X → Y, Z → Y\ng = DiGraph(3)\nadd_edge!(g, 1, 2)  # Z → X\nadd_edge!(g, 1, 3)  # Z → Y\nadd_edge!(g, 2, 3)  # X → Y\n\n# X and Y are d-separated by Z\nd_separated(g, 2, 3, [1])  # true","category":"section"},{"location":"examples.html#Ancestors-and-Descendants","page":"Examples","title":"Ancestors and Descendants","text":"# Get ancestors of a node\nancestors = get_ancestors(g, 3)  # {1, 2}\n\n# Get descendants of a node\ndescendants = get_descendants(g, 1)  # {2, 3}","category":"section"},{"location":"examples.html#Identification","page":"Examples","title":"Identification","text":"","category":"section"},{"location":"examples.html#Backdoor-Criterion","page":"Examples","title":"Backdoor Criterion","text":"# Find backdoor adjustment set\nadj_set = backdoor_adjustment_set(g, 2, 3)  # Set([1])\n\n# Check if backdoor adjustment is possible\nis_backdoor_adjustable(g, 2, 3)  # true","category":"section"},{"location":"examples.html#Frontdoor-Criterion","page":"Examples","title":"Frontdoor Criterion","text":"# Create frontdoor example: U → X → M → Y, U → Y\ng_frontdoor = DiGraph(4)\nadd_edge!(g_frontdoor, 1, 2)  # U → X\nadd_edge!(g_frontdoor, 1, 4)  # U → Y\nadd_edge!(g_frontdoor, 2, 3)  # X → M\nadd_edge!(g_frontdoor, 3, 4)  # M → Y\n\n# Find frontdoor mediators\nmediators = find_frontdoor_mediators(g_frontdoor, 2, 4)  # [3]","category":"section"},{"location":"examples.html#SCM-Framework","page":"Examples","title":"SCM Framework","text":"","category":"section"},{"location":"examples.html#GraphSCM","page":"Examples","title":"GraphSCM","text":"# Create a GraphSCM\ng = DiGraph(2)\nadd_edge!(g, 1, 2)\n\nequations = Dict(\n    1 => (u) -> u,\n    2 => (x, u) -> x + u\n)\n\nexogenous = Set([1])\n\nscm = GraphSCM(g, equations, exogenous)\n\nFor more examples, see the package's examples/ directory.","category":"section"},{"location":"api/graphs.html#Graph-Operations","page":"Graph Operations","title":"Graph Operations","text":"","category":"section"},{"location":"api/graphs.html#CausalDynamics.d_separated","page":"Graph Operations","title":"CausalDynamics.d_separated","text":"d_separated(g, X, Y, Z)\n\nCheck if nodes X and Y are d-separated by set Z in directed acyclic graph g.\n\nArguments\n\ng: A directed acyclic graph (DiGraph)\nX: Source node or set of nodes\nY: Target node or set of nodes\nZ: Conditioning set (set of nodes to condition on)\n\nReturns\n\ntrue if X and Y are d-separated by Z, false otherwise\n\nExamples\n\nusing CausalDynamics, Graphs\n\ng = DiGraph(3)\nadd_edge!(g, 1, 2)  # X → Y\nadd_edge!(g, 3, 1)  # Z → X\nadd_edge!(g, 3, 2)  # Z → Y\n\n# X and Y are d-separated by Z (Z blocks the path)\nd_separated(g, 1, 2, [3])  # true\n\n# X and Y are not d-separated without conditioning\nd_separated(g, 1, 2, [])  # false\n\nReferences\n\nPearl, J. (2009). Causality, Chapter 1\n\n\n\n\n\n","category":"function"},{"location":"api/graphs.html#CausalDynamics.get_ancestors","page":"Graph Operations","title":"CausalDynamics.get_ancestors","text":"get_ancestors(g, nodes)\n\nGet the set of all ancestors of the given nodes.\n\nAn ancestor of node X is any node that has a directed path to X.\n\nArguments\n\ng: Directed acyclic graph\nnodes: Node or set of nodes\n\nReturns\n\nSet of ancestor nodes\n\nExamples\n\nusing CausalDynamics, Graphs\n\ng = DiGraph(4)\nadd_edge!(g, 1, 3)  # X → Z\nadd_edge!(g, 2, 3)  # Y → Z\nadd_edge!(g, 3, 4)  # Z → W\n\nancestors = get_ancestors(g, 4)  # {1, 2, 3}\n\n\n\n\n\n","category":"function"},{"location":"api/graphs.html#CausalDynamics.get_descendants","page":"Graph Operations","title":"CausalDynamics.get_descendants","text":"get_descendants(g, nodes)\n\nGet the set of all descendants of the given nodes.\n\nA descendant of node X is any node that has a directed path from X.\n\nArguments\n\ng: Directed acyclic graph\nnodes: Node or set of nodes\n\nReturns\n\nSet of descendant nodes\n\nExamples\n\nusing CausalDynamics, Graphs\n\ng = DiGraph(4)\nadd_edge!(g, 1, 2)  # X → Y\nadd_edge!(g, 1, 3)  # X → Z\nadd_edge!(g, 2, 4)  # Y → W\n\ndescendants = get_descendants(g, 1)  # {2, 3, 4}\n\n\n\n\n\n","category":"function"},{"location":"api/graphs.html#CausalDynamics.get_parents","page":"Graph Operations","title":"CausalDynamics.get_parents","text":"get_parents(g, nodes)\n\nGet the set of parents of the given nodes.\n\nArguments\n\ng: Directed acyclic graph\nnodes: Node or set of nodes\n\nReturns\n\nSet of parent nodes\n\n\n\n\n\n","category":"function"},{"location":"api/graphs.html#CausalDynamics.get_children","page":"Graph Operations","title":"CausalDynamics.get_children","text":"get_children(g, nodes)\n\nGet the set of children of the given nodes.\n\nArguments\n\ng: Directed acyclic graph\nnodes: Node or set of nodes\n\nReturns\n\nSet of child nodes\n\n\n\n\n\n","category":"function"},{"location":"api/graphs.html#CausalDynamics.markov_boundary","page":"Graph Operations","title":"CausalDynamics.markov_boundary","text":"markov_boundary(g, Y)\n\nCompute the Markov boundary of node Y.\n\nThe Markov boundary of Y is the minimal set that d-separates Y from all other nodes. It consists of: parents of Y, children of Y, and parents of children of Y.\n\nArguments\n\ng: Directed acyclic graph\nY: Target node\n\nReturns\n\nSet of nodes in the Markov boundary\n\nExamples\n\nusing CausalDynamics, Graphs\n\ng = DiGraph(4)\nadd_edge!(g, 1, 2)  # X → Y\nadd_edge!(g, 3, 2)  # Z → Y\nadd_edge!(g, 2, 4)  # Y → W\nadd_edge!(g, 5, 4)  # V → W\n\nmb = markov_boundary(g, 2)  # {1, 3, 4, 5}\n# Parents: {1, 3}\n# Children: {4}\n# Parents of children: {5}\n\n\n\n\n\n","category":"function"},{"location":"api/graphs.html#CausalDynamics.find_backdoor_paths","page":"Graph Operations","title":"CausalDynamics.find_backdoor_paths","text":"find_backdoor_paths(g, X, Y)\n\nFind all backdoor paths from X to Y.\n\nA backdoor path is a path that starts with an edge pointing into X.\n\nArguments\n\ng: Directed acyclic graph\nX: Source node\nY: Target node\n\nReturns\n\nVector of backdoor paths (each path is a vector of nodes)\n\nExamples\n\nusing CausalDynamics, Graphs\n\ng = DiGraph(4)\nadd_edge!(g, 1, 2)  # Z → X\nadd_edge!(g, 1, 3)  # Z → Y\nadd_edge!(g, 2, 3)  # X → Y\n\n# Backdoor path: X ← Z → Y\npaths = find_backdoor_paths(g, 2, 3)  # [[1, 3]]\n\n\n\n\n\n","category":"function"},{"location":"api/graphs.html#CausalDynamics.find_directed_paths","page":"Graph Operations","title":"CausalDynamics.find_directed_paths","text":"find_directed_paths(g, X, Y)\n\nFind all directed paths from X to Y.\n\nA directed path follows the direction of edges.\n\nArguments\n\ng: Directed acyclic graph\nX: Source node\nY: Target node\n\nReturns\n\nVector of directed paths\n\n\n\n\n\n","category":"function"},{"location":"api/graphs.html#CausalDynamics.is_dag","page":"Graph Operations","title":"CausalDynamics.is_dag","text":"is_dag(g)\n\nCheck if graph g is a directed acyclic graph (DAG).\n\nArguments\n\ng: Directed graph\n\nReturns\n\ntrue if g is a DAG, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"api/graphs.html#CausalDynamics.validate_causal_graph","page":"Graph Operations","title":"CausalDynamics.validate_causal_graph","text":"validate_causal_graph(g)\n\nValidate that graph g is a valid causal graph (DAG).\n\nArguments\n\ng: Directed graph\n\nReturns\n\ntrue if valid, throws error if not\n\nThrows\n\nArgumentError if graph is not a DAG\n\n\n\n\n\n","category":"function"},{"location":"api/graphs.html#CausalDynamics.create_causal_graph","page":"Graph Operations","title":"CausalDynamics.create_causal_graph","text":"create_causal_graph(edges)\n\nCreate a causal graph from a list of edges.\n\nArguments\n\nedges: Vector of tuples (source, target) or dictionary\n\nReturns\n\nDiGraph object\n\nExamples\n\nusing CausalDynamics\n\n# From edge list\nedges = [(1, 2), (3, 1), (3, 2)]\ng = create_causal_graph(edges)\n\n# From dictionary\nedge_dict = Dict(1 => [2], 3 => [1, 2])\ng = create_causal_graph(edge_dict)\n\n\n\n\n\n","category":"function"},{"location":"index.html#CausalDynamics.jl","page":"Home","title":"CausalDynamics.jl","text":"A Julia package for causal graph operations and identification algorithms, designed for Causal Dynamical Models (CDMs) and integration with the SciML ecosystem.","category":"section"},{"location":"index.html#Features","page":"Home","title":"Features","text":"Causal Graph Operations: d-separation, path finding, ancestral/descendant sets, Markov boundary\nIdentification Algorithms: Backdoor criterion, frontdoor criterion, instrumental variables\nStructural Causal Model (SCM) Framework: Graph-based and symbolic SCM representation\nIntervention Operators: do(·) operators for causal interventions\nSciML Integration: Uses ModelingToolkit.jl, Symbolics.jl, Graphs.jl","category":"section"},{"location":"index.html#Quick-Start","page":"Home","title":"Quick Start","text":"using CausalDynamics\nusing Graphs\n\n# Create a causal graph\ng = DiGraph(3)\nadd_edge!(g, 1, 2)  # Z → X\nadd_edge!(g, 1, 3)  # Z → Y\nadd_edge!(g, 2, 3)  # X → Y\n\n# Check d-separation\nd_separated(g, 2, 3, [1])  # true (Z blocks the path)\n\n# Find backdoor adjustment set\nbackdoor_adjustment_set(g, 2, 3)  # Set([1])","category":"section"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"CausalDynamics\")","category":"section"},{"location":"index.html#Documentation","page":"Home","title":"Documentation","text":"See the API Reference for detailed documentation of all functions.\n\nFor conceptual background and worked examples, see the CDCS Book.","category":"section"},{"location":"index.html#References","page":"Home","title":"References","text":"Pearl, J. (2009). Causality: Models, Reasoning, and Inference\nHofmann et al. (2023). Spectral DCM with ModelingToolkit.jl\nShpitser, I., & Pearl, J. (2006). Identification of joint interventional distributions","category":"section"},{"location":"index.html#CausalDynamics.CausalDynamics","page":"Home","title":"CausalDynamics.CausalDynamics","text":"CausalDynamics.jl\n\nA Julia package for causal graph operations and identification algorithms, designed for Causal Dynamical Models (CDMs) and integration with the SciML ecosystem.\n\nThis package provides:\n\nCausal graph operations (d-separation, paths, sets)\nIdentification algorithms (backdoor, frontdoor, do-calculus)\nStructural Causal Model (SCM) framework\nIntervention operators and counterfactual reasoning\n\nExamples\n\nusing CausalDynamics\nusing Graphs\n\n# Create a causal graph\ng = DiGraph(4)\nadd_edge!(g, 1, 2)  # X → Y\nadd_edge!(g, 3, 1)  # Z → X\nadd_edge!(g, 3, 2)  # Z → Y\n\n# Check d-separation\nd_separated(g, 1, 2, [3])  # true (Z blocks the path)\n\n# Find backdoor adjustment set\nbackdoor_adjustment_set(g, 1, 2)  # [3]\n\nReferences\n\nPearl, J. (2009). Causality: Models, Reasoning, and Inference\nHofmann et al. (2023). Spectral DCM with ModelingToolkit.jl\nShpitser, I., & Pearl, J. (2006). Identification of joint interventional distributions\n\n\n\n\n\n","category":"module"}]
}
